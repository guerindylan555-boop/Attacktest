#!/usr/bin/env python3
"""
Comprehensive Vulnerability Analysis Script
Combines QARK, AndroGuard, and custom analysis for MaynDrive APK
"""

import json
import os
import sys
from datetime import datetime
from pathlib import Path

# Add androguard to path
sys.path.append('/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/mobsf_env/lib/python3.13/site-packages')

try:
    from androguard.core.bytecodes import apk
    from androguard.core.bytecodes import dvm
    from androguard.core.analysis import analysis
    from androguard.misc import AnalyzeAPK
except ImportError as e:
    print(f"Error importing androguard: {e}")
    sys.exit(1)

class VulnerabilityAnalyzer:
    def __init__(self, apk_path, output_dir):
        self.apk_path = apk_path
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Load APK
        try:
            self.a, self.d, self.dx = AnalyzeAPK(apk_path)
            print(f"Successfully loaded APK: {apk_path}")
        except Exception as e:
            print(f"Error loading APK: {e}")
            sys.exit(1)
        
        self.vulnerabilities = []
        self.analysis_results = {
            "metadata": {
                "apk_path": apk_path,
                "analysis_timestamp": datetime.now().isoformat(),
                "package_name": self.a.get_package(),
                "version_name": self.a.get_androidversion_name(),
                "version_code": self.a.get_androidversion_code(),
                "target_sdk": self.a.get_target_sdk_version(),
                "min_sdk": self.a.get_min_sdk_version(),
                "permissions": self.a.get_permissions(),
                "activities": self.a.get_activities(),
                "services": self.a.get_services(),
                "receivers": self.a.get_receivers(),
                "providers": self.a.get_providers()
            },
            "vulnerabilities": [],
            "security_assessment": {}
        }

    def analyze_permissions(self):
        """Analyze dangerous permissions and their usage"""
        print("Analyzing permissions...")
        
        dangerous_permissions = [
            "android.permission.ACCESS_FINE_LOCATION",
            "android.permission.ACCESS_COARSE_LOCATION", 
            "android.permission.CAMERA",
            "android.permission.RECORD_AUDIO",
            "android.permission.READ_EXTERNAL_STORAGE",
            "android.permission.WRITE_EXTERNAL_STORAGE",
            "android.permission.READ_CONTACTS",
            "android.permission.WRITE_CONTACTS",
            "android.permission.READ_SMS",
            "android.permission.SEND_SMS",
            "android.permission.READ_PHONE_STATE",
            "android.permission.CALL_PHONE",
            "android.permission.READ_CALL_LOG",
            "android.permission.WRITE_CALL_LOG"
        ]
        
        found_dangerous = []
        for perm in self.a.get_permissions():
            if perm in dangerous_permissions:
                found_dangerous.append(perm)
        
        if found_dangerous:
            self.add_vulnerability(
                "Dangerous Permissions",
                "HIGH",
                "The app requests dangerous permissions that can access sensitive user data",
                {
                    "permissions": found_dangerous,
                    "count": len(found_dangerous),
                    "recommendation": "Implement runtime permission requests and review necessity of each permission"
                }
            )

    def analyze_network_security(self):
        """Analyze network security configurations"""
        print("Analyzing network security...")
        
        manifest = self.a.get_android_manifest_xml()
        network_security_issues = []
        
        # Check for cleartext traffic
        if manifest.get("android:usesCleartextTraffic") == "true":
            network_security_issues.append("Cleartext HTTP traffic allowed")
        
        # Check for network security config
        if not manifest.get("android:networkSecurityConfig"):
            network_security_issues.append("No network security configuration found")
        
        # Check for certificate pinning
        # This would require deeper analysis of the network security config file
        # For now, we'll flag if no network security config is present
        
        if network_security_issues:
            self.add_vulnerability(
                "Network Security Issues",
                "HIGH",
                "The app has network security vulnerabilities that could allow MITM attacks",
                {
                    "issues": network_security_issues,
                    "recommendation": "Implement certificate pinning and disable cleartext traffic"
                }
            )

    def analyze_hardcoded_secrets(self):
        """Analyze for hardcoded secrets in the APK"""
        print("Analyzing for hardcoded secrets...")
        
        # Get all strings from the APK
        strings = self.a.get_strings()
        
        # Patterns to look for
        secret_patterns = [
            r'[A-Za-z0-9+/]{40,}={0,2}',  # Base64-like strings
            r'[A-Za-z0-9]{32,}',  # Long alphanumeric strings
            r'Bearer\s+[A-Za-z0-9\-_\.]+',  # Bearer tokens
            r'eyJ[A-Za-z0-9\-_\.]+',  # JWT tokens
            r'api[_-]?key[_-]?[A-Za-z0-9]+',  # API keys
            r'secret[_-]?[A-Za-z0-9]+',  # Secrets
            r'password[_-]?[A-Za-z0-9]+',  # Passwords
        ]
        
        import re
        potential_secrets = []
        
        for string in strings:
            for pattern in secret_patterns:
                if re.search(pattern, string, re.IGNORECASE):
                    potential_secrets.append(string)
                    break
        
        # Filter out common false positives
        filtered_secrets = []
        false_positives = [
            'android', 'google', 'com', 'org', 'net', 'http', 'https',
            'www', 'api', 'app', 'mobile', 'version', 'build', 'debug',
            'release', 'test', 'prod', 'dev', 'staging'
        ]
        
        for secret in potential_secrets:
            if not any(fp in secret.lower() for fp in false_positives):
                if len(secret) > 10:  # Only consider longer strings
                    filtered_secrets.append(secret)
        
        if filtered_secrets:
            self.add_vulnerability(
                "Potential Hardcoded Secrets",
                "MEDIUM",
                "Potential hardcoded secrets found in the APK",
                {
                    "secrets_found": len(filtered_secrets),
                    "sample_secrets": filtered_secrets[:10],  # Show first 10
                    "recommendation": "Review and remove any hardcoded secrets, use secure storage mechanisms"
                }
            )

    def analyze_exported_components(self):
        """Analyze exported components for security issues"""
        print("Analyzing exported components...")
        
        exported_issues = []
        
        # Check exported activities
        for activity in self.a.get_activities():
            if self.a.is_exported(activity):
                exported_issues.append(f"Exported Activity: {activity}")
        
        # Check exported services
        for service in self.a.get_services():
            if self.a.is_exported(service):
                exported_issues.append(f"Exported Service: {service}")
        
        # Check exported receivers
        for receiver in self.a.get_receivers():
            if self.a.is_exported(receiver):
                exported_issues.append(f"Exported Receiver: {receiver}")
        
        # Check exported providers
        for provider in self.a.get_providers():
            if self.a.is_exported(provider):
                exported_issues.append(f"Exported Provider: {provider}")
        
        if exported_issues:
            self.add_vulnerability(
                "Exported Components",
                "MEDIUM",
                "The app has exported components that could be accessed by other apps",
                {
                    "exported_components": exported_issues,
                    "count": len(exported_issues),
                    "recommendation": "Review exported components and add proper intent filters or set android:exported=false"
                }
            )

    def analyze_debugging_features(self):
        """Analyze for debugging and development features"""
        print("Analyzing debugging features...")
        
        manifest = self.a.get_android_manifest_xml()
        debug_issues = []
        
        # Check for debuggable flag
        if manifest.get("android:debuggable") == "true":
            debug_issues.append("App is debuggable")
        
        # Check for backup enabled
        if manifest.get("android:allowBackup") == "true":
            debug_issues.append("Backup is enabled")
        
        # Check for testOnly flag
        if manifest.get("android:testOnly") == "true":
            debug_issues.append("App is marked as test-only")
        
        if debug_issues:
            self.add_vulnerability(
                "Debugging Features",
                "MEDIUM",
                "The app has debugging or development features enabled",
                {
                    "issues": debug_issues,
                    "recommendation": "Disable debugging features in production builds"
                }
            )

    def analyze_crypto_usage(self):
        """Analyze cryptographic implementations"""
        print("Analyzing cryptographic usage...")
        
        # Get all method calls
        crypto_issues = []
        
        # Look for weak cryptographic algorithms
        weak_algorithms = [
            "DES", "3DES", "MD5", "SHA1", "RC4", "MD4"
        ]
        
        # This would require deeper analysis of the bytecode
        # For now, we'll do a basic string search
        strings = self.a.get_strings()
        for string in strings:
            for algo in weak_algorithms:
                if algo in string.upper():
                    crypto_issues.append(f"Weak algorithm found: {algo}")
        
        if crypto_issues:
            self.add_vulnerability(
                "Weak Cryptographic Algorithms",
                "HIGH",
                "The app may use weak cryptographic algorithms",
                {
                    "issues": crypto_issues,
                    "recommendation": "Use strong cryptographic algorithms like AES-256, SHA-256, etc."
                }
            )

    def add_vulnerability(self, name, severity, description, details):
        """Add a vulnerability to the results"""
        vulnerability = {
            "name": name,
            "severity": severity,
            "description": description,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.vulnerabilities.append(vulnerability)
        self.analysis_results["vulnerabilities"].append(vulnerability)

    def generate_security_assessment(self):
        """Generate overall security assessment"""
        print("Generating security assessment...")
        
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0}
        for vuln in self.vulnerabilities:
            severity_counts[vuln["severity"]] += 1
        
        # Calculate risk score
        risk_score = (severity_counts["CRITICAL"] * 4 + 
                     severity_counts["HIGH"] * 3 + 
                     severity_counts["MEDIUM"] * 2 + 
                     severity_counts["LOW"] * 1)
        
        # Determine overall risk level
        if risk_score >= 12:
            risk_level = "CRITICAL"
        elif risk_score >= 8:
            risk_level = "HIGH"
        elif risk_score >= 4:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        self.analysis_results["security_assessment"] = {
            "overall_risk_level": risk_level,
            "risk_score": risk_score,
            "vulnerability_counts": severity_counts,
            "total_vulnerabilities": len(self.vulnerabilities),
            "recommendations": [
                "Implement runtime permissions for dangerous permissions",
                "Add certificate pinning for network security",
                "Review and remove any hardcoded secrets",
                "Audit exported components and add proper security controls",
                "Disable debugging features in production builds",
                "Use strong cryptographic algorithms"
            ]
        }

    def save_results(self):
        """Save analysis results to files"""
        print("Saving results...")
        
        # Save JSON report
        json_path = self.output_dir / "comprehensive_vulnerability_analysis.json"
        with open(json_path, 'w') as f:
            json.dump(self.analysis_results, f, indent=2)
        
        # Save markdown report
        md_path = self.output_dir / "comprehensive_vulnerability_analysis.md"
        with open(md_path, 'w') as f:
            f.write(self.generate_markdown_report())
        
        print(f"Results saved to {json_path} and {md_path}")

    def generate_markdown_report(self):
        """Generate markdown report"""
        report = f"""# Comprehensive Vulnerability Analysis Report

## 📊 Analysis Summary

**Target APK**: {self.analysis_results['metadata']['apk_path']}  
**Package Name**: {self.analysis_results['metadata']['package_name']}  
**Version**: {self.analysis_results['metadata']['version_name']} (Code: {self.analysis_results['metadata']['version_code']})  
**Target SDK**: {self.analysis_results['metadata']['target_sdk']}  
**Min SDK**: {self.analysis_results['metadata']['min_sdk']}  
**Analysis Date**: {self.analysis_results['metadata']['analysis_timestamp']}  

## 🚨 Security Assessment

**Overall Risk Level**: {self.analysis_results['security_assessment']['overall_risk_level']}  
**Risk Score**: {self.analysis_results['security_assessment']['risk_score']}/20  
**Total Vulnerabilities**: {self.analysis_results['security_assessment']['total_vulnerabilities']}  

### Vulnerability Breakdown:
- **CRITICAL**: {self.analysis_results['security_assessment']['vulnerability_counts']['CRITICAL']}
- **HIGH**: {self.analysis_results['security_assessment']['vulnerability_counts']['HIGH']}
- **MEDIUM**: {self.analysis_results['security_assessment']['vulnerability_counts']['MEDIUM']}
- **LOW**: {self.analysis_results['security_assessment']['vulnerability_counts']['LOW']}

## 🔍 Detailed Findings

"""
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            report += f"""### {i}. {vuln['name']} - {vuln['severity']}

**Description**: {vuln['description']}

**Details**:
"""
            for key, value in vuln['details'].items():
                if isinstance(value, list):
                    report += f"- **{key.replace('_', ' ').title()}**: {', '.join(map(str, value))}\n"
                else:
                    report += f"- **{key.replace('_', ' ').title()}**: {value}\n"
            
            report += "\n---\n\n"
        
        report += """## 🛡️ Recommendations

"""
        for i, rec in enumerate(self.analysis_results['security_assessment']['recommendations'], 1):
            report += f"{i}. {rec}\n"
        
        report += f"""
## 📋 App Information

### Permissions ({len(self.analysis_results['metadata']['permissions'])} total):
"""
        for perm in self.analysis_results['metadata']['permissions']:
            report += f"- {perm}\n"
        
        report += f"""
### Activities ({len(self.analysis_results['metadata']['activities'])} total):
"""
        for activity in self.analysis_results['metadata']['activities']:
            report += f"- {activity}\n"
        
        report += f"""
### Services ({len(self.analysis_results['metadata']['services'])} total):
"""
        for service in self.analysis_results['metadata']['services']:
            report += f"- {service}\n"
        
        report += f"""
### Receivers ({len(self.analysis_results['metadata']['receivers'])} total):
"""
        for receiver in self.analysis_results['metadata']['receivers']:
            report += f"- {receiver}\n"
        
        report += f"""
### Providers ({len(self.analysis_results['metadata']['providers'])} total):
"""
        for provider in self.analysis_results['metadata']['providers']:
            report += f"- {provider}\n"
        
        return report

    def run_analysis(self):
        """Run complete vulnerability analysis"""
        print("Starting comprehensive vulnerability analysis...")
        
        self.analyze_permissions()
        self.analyze_network_security()
        self.analyze_hardcoded_secrets()
        self.analyze_exported_components()
        self.analyze_debugging_features()
        self.analyze_crypto_usage()
        
        self.generate_security_assessment()
        self.save_results()
        
        print(f"Analysis complete! Found {len(self.vulnerabilities)} vulnerabilities.")
        return self.analysis_results

def main():
    apk_path = "/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/mobsf_analysis/mayndrive_extracted/base.apk"
    output_dir = "/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/comprehensive_analysis_results"
    
    analyzer = VulnerabilityAnalyzer(apk_path, output_dir)
    results = analyzer.run_analysis()
    
    print("\n" + "="*50)
    print("ANALYSIS SUMMARY")
    print("="*50)
    print(f"Overall Risk Level: {results['security_assessment']['overall_risk_level']}")
    print(f"Total Vulnerabilities: {results['security_assessment']['total_vulnerabilities']}")
    print(f"Risk Score: {results['security_assessment']['risk_score']}/20")
    
    print("\nVulnerabilities by Severity:")
    for severity, count in results['security_assessment']['vulnerability_counts'].items():
        if count > 0:
            print(f"  {severity}: {count}")

if __name__ == "__main__":
    main()
