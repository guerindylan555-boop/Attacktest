#!/usr/bin/env python3
"""
Simple Vulnerability Analysis Script
Analyzes APK using basic file operations and QARK results
"""

import json
import os
import re
import zipfile
from datetime import datetime
from pathlib import Path

class SimpleVulnerabilityAnalyzer:
    def __init__(self, apk_path, qark_results_path, output_dir):
        self.apk_path = apk_path
        self.qark_results_path = qark_results_path
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        self.vulnerabilities = []
        self.analysis_results = {
            "metadata": {
                "apk_path": apk_path,
                "analysis_timestamp": datetime.now().isoformat(),
                "tools_used": ["QARK", "Custom Analysis"]
            },
            "vulnerabilities": [],
            "security_assessment": {}
        }

    def load_qark_results(self):
        """Load and parse QARK results"""
        print("Loading QARK results...")
        
        try:
            with open(self.qark_results_path, 'r') as f:
                qark_data = json.load(f)
            
            # Filter out false positives from QARK
            real_vulnerabilities = []
            for item in qark_data:
                # Skip "Potential API Key" findings in binary files
                if (item.get('name') == 'Potential API Key found' and 
                    any(ext in item.get('file_object', '') for ext in ['.ttf', '.properties', '.gz', '.webp', '.bin'])):
                    continue
                
                # Keep real vulnerabilities
                if item.get('severity') in ['WARNING', 'ERROR', 'CRITICAL']:
                    real_vulnerabilities.append(item)
            
            return real_vulnerabilities
            
        except Exception as e:
            print(f"Error loading QARK results: {e}")
            return []

    def analyze_apk_structure(self):
        """Analyze APK structure and extract basic information"""
        print("Analyzing APK structure...")
        
        try:
            with zipfile.ZipFile(self.apk_path, 'r') as apk:
                files = apk.namelist()
                
                # Look for AndroidManifest.xml
                manifest_files = [f for f in files if 'AndroidManifest.xml' in f]
                if manifest_files:
                    print(f"Found AndroidManifest.xml: {manifest_files[0]}")
                
                # Look for certificate files
                cert_files = [f for f in files if f.startswith('META-INF/') and f.endswith(('.RSA', '.DSA', '.EC'))]
                if cert_files:
                    print(f"Found certificate files: {cert_files}")
                    self.add_vulnerability(
                        "APK Signing",
                        "INFO",
                        "APK is digitally signed",
                        {"certificate_files": cert_files}
                    )
                else:
                    self.add_vulnerability(
                        "Unsigned APK",
                        "HIGH",
                        "APK is not digitally signed",
                        {"recommendation": "Sign the APK with a valid certificate"}
                    )
                
                # Look for network security config
                network_config_files = [f for f in files if 'network_security_config' in f.lower()]
                if not network_config_files:
                    self.add_vulnerability(
                        "Missing Network Security Config",
                        "MEDIUM",
                        "No network security configuration found",
                        {"recommendation": "Implement network security configuration with certificate pinning"}
                    )
                
                # Look for debug information
                debug_files = [f for f in files if 'debug' in f.lower() or 'test' in f.lower()]
                if debug_files:
                    self.add_vulnerability(
                        "Debug Files Present",
                        "LOW",
                        "Debug or test files found in APK",
                        {"debug_files": debug_files[:10]}  # Show first 10
                    )
                
        except Exception as e:
            print(f"Error analyzing APK structure: {e}")

    def analyze_strings(self):
        """Analyze strings in the APK for potential secrets"""
        print("Analyzing strings for potential secrets...")
        
        try:
            with zipfile.ZipFile(self.apk_path, 'r') as apk:
                # Look for classes.dex
                dex_files = [f for f in apk.namelist() if f.endswith('.dex')]
                
                if dex_files:
                    # Extract and analyze classes.dex
                    dex_content = apk.read(dex_files[0])
                    
                    # Look for potential API keys, tokens, etc.
                    potential_secrets = []
                    
                    # Common patterns
                    patterns = [
                        r'Bearer\s+[A-Za-z0-9\-_\.]+',
                        r'eyJ[A-Za-z0-9\-_\.]+',
                        r'api[_-]?key[_-]?[A-Za-z0-9]+',
                        r'secret[_-]?[A-Za-z0-9]+',
                        r'password[_-]?[A-Za-z0-9]+',
                        r'[A-Za-z0-9+/]{40,}={0,2}',  # Base64-like
                    ]
                    
                    for pattern in patterns:
                        matches = re.findall(pattern, dex_content.decode('utf-8', errors='ignore'), re.IGNORECASE)
                        potential_secrets.extend(matches)
                    
                    # Filter out common false positives
                    filtered_secrets = []
                    false_positives = [
                        'android', 'google', 'com', 'org', 'net', 'http', 'https',
                        'www', 'api', 'app', 'mobile', 'version', 'build', 'debug',
                        'release', 'test', 'prod', 'dev', 'staging', 'manifest'
                    ]
                    
                    for secret in potential_secrets:
                        if not any(fp in secret.lower() for fp in false_positives):
                            if len(secret) > 10:  # Only consider longer strings
                                filtered_secrets.append(secret)
                    
                    if filtered_secrets:
                        self.add_vulnerability(
                            "Potential Hardcoded Secrets",
                            "MEDIUM",
                            "Potential hardcoded secrets found in APK",
                            {
                                "secrets_found": len(filtered_secrets),
                                "sample_secrets": filtered_secrets[:5],  # Show first 5
                                "recommendation": "Review and remove any hardcoded secrets"
                            }
                        )
                    else:
                        self.add_vulnerability(
                            "Hardcoded Secrets Check",
                            "INFO",
                            "No obvious hardcoded secrets found",
                            {"status": "Clean"}
                        )
                        
        except Exception as e:
            print(f"Error analyzing strings: {e}")

    def add_vulnerability(self, name, severity, description, details):
        """Add a vulnerability to the results"""
        vulnerability = {
            "name": name,
            "severity": severity,
            "description": description,
            "details": details,
            "timestamp": datetime.now().isoformat()
        }
        self.vulnerabilities.append(vulnerability)
        self.analysis_results["vulnerabilities"].append(vulnerability)

    def process_qark_vulnerabilities(self, qark_vulns):
        """Process QARK vulnerabilities and add to results"""
        print("Processing QARK vulnerabilities...")
        
        for vuln in qark_vulns:
            severity_map = {
                'WARNING': 'MEDIUM',
                'ERROR': 'HIGH',
                'CRITICAL': 'CRITICAL',
                'INFO': 'LOW'
            }
            
            severity = severity_map.get(vuln.get('severity', 'INFO'), 'LOW')
            
            self.add_vulnerability(
                vuln.get('name', 'Unknown'),
                severity,
                vuln.get('description', 'No description available'),
                {
                    "source": "QARK",
                    "file": vuln.get('file_object', 'Unknown'),
                    "line": vuln.get('line_number', 'Unknown')
                }
            )

    def generate_security_assessment(self):
        """Generate overall security assessment"""
        print("Generating security assessment...")
        
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "INFO": 0}
        for vuln in self.vulnerabilities:
            severity_counts[vuln["severity"]] += 1
        
        # Calculate risk score
        risk_score = (severity_counts["CRITICAL"] * 4 + 
                     severity_counts["HIGH"] * 3 + 
                     severity_counts["MEDIUM"] * 2 + 
                     severity_counts["LOW"] * 1)
        
        # Determine overall risk level
        if risk_score >= 12:
            risk_level = "CRITICAL"
        elif risk_score >= 8:
            risk_level = "HIGH"
        elif risk_score >= 4:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        self.analysis_results["security_assessment"] = {
            "overall_risk_level": risk_level,
            "risk_score": risk_score,
            "vulnerability_counts": severity_counts,
            "total_vulnerabilities": len(self.vulnerabilities),
            "recommendations": [
                "Review all HIGH and CRITICAL severity vulnerabilities",
                "Implement proper APK signing for production releases",
                "Add network security configuration with certificate pinning",
                "Remove any hardcoded secrets and use secure storage",
                "Disable debugging features in production builds",
                "Regular security assessments and code reviews"
            ]
        }

    def save_results(self):
        """Save analysis results to files"""
        print("Saving results...")
        
        # Save JSON report
        json_path = self.output_dir / "simple_vulnerability_analysis.json"
        with open(json_path, 'w') as f:
            json.dump(self.analysis_results, f, indent=2)
        
        # Save markdown report
        md_path = self.output_dir / "simple_vulnerability_analysis.md"
        with open(md_path, 'w') as f:
            f.write(self.generate_markdown_report())
        
        print(f"Results saved to {json_path} and {md_path}")

    def generate_markdown_report(self):
        """Generate markdown report"""
        report = f"""# Simple Vulnerability Analysis Report

## 📊 Analysis Summary

**Target APK**: {self.analysis_results['metadata']['apk_path']}  
**Analysis Date**: {self.analysis_results['metadata']['analysis_timestamp']}  
**Tools Used**: {', '.join(self.analysis_results['metadata']['tools_used'])}  

## 🚨 Security Assessment

**Overall Risk Level**: {self.analysis_results['security_assessment']['overall_risk_level']}  
**Risk Score**: {self.analysis_results['security_assessment']['risk_score']}/20  
**Total Vulnerabilities**: {self.analysis_results['security_assessment']['total_vulnerabilities']}  

### Vulnerability Breakdown:
- **CRITICAL**: {self.analysis_results['security_assessment']['vulnerability_counts']['CRITICAL']}
- **HIGH**: {self.analysis_results['security_assessment']['vulnerability_counts']['HIGH']}
- **MEDIUM**: {self.analysis_results['security_assessment']['vulnerability_counts']['MEDIUM']}
- **LOW**: {self.analysis_results['security_assessment']['vulnerability_counts']['LOW']}
- **INFO**: {self.analysis_results['security_assessment']['vulnerability_counts']['INFO']}

## 🔍 Detailed Findings

"""
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            report += f"""### {i}. {vuln['name']} - {vuln['severity']}

**Description**: {vuln['description']}

**Details**:
"""
            for key, value in vuln['details'].items():
                if isinstance(value, list):
                    report += f"- **{key.replace('_', ' ').title()}**: {', '.join(map(str, value))}\n"
                else:
                    report += f"- **{key.replace('_', ' ').title()}**: {value}\n"
            
            report += "\n---\n\n"
        
        report += """## 🛡️ Recommendations

"""
        for i, rec in enumerate(self.analysis_results['security_assessment']['recommendations'], 1):
            report += f"{i}. {rec}\n"
        
        return report

    def run_analysis(self):
        """Run complete vulnerability analysis"""
        print("Starting simple vulnerability analysis...")
        
        # Load QARK results
        qark_vulns = self.load_qark_results()
        
        # Analyze APK structure
        self.analyze_apk_structure()
        
        # Analyze strings for secrets
        self.analyze_strings()
        
        # Process QARK vulnerabilities
        self.process_qark_vulnerabilities(qark_vulns)
        
        # Generate security assessment
        self.generate_security_assessment()
        
        # Save results
        self.save_results()
        
        print(f"Analysis complete! Found {len(self.vulnerabilities)} vulnerabilities.")
        return self.analysis_results

def main():
    apk_path = "/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/mobsf_analysis/mayndrive_extracted/base.apk"
    qark_results_path = "/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/qark_results/qark_report.json"
    output_dir = "/home/ubuntu/Desktop/Project/Attacktest/claude_analysis/simple_analysis_results"
    
    analyzer = SimpleVulnerabilityAnalyzer(apk_path, qark_results_path, output_dir)
    results = analyzer.run_analysis()
    
    print("\n" + "="*50)
    print("ANALYSIS SUMMARY")
    print("="*50)
    print(f"Overall Risk Level: {results['security_assessment']['overall_risk_level']}")
    print(f"Total Vulnerabilities: {results['security_assessment']['total_vulnerabilities']}")
    print(f"Risk Score: {results['security_assessment']['risk_score']}/20")
    
    print("\nVulnerabilities by Severity:")
    for severity, count in results['security_assessment']['vulnerability_counts'].items():
        if count > 0:
            print(f"  {severity}: {count}")

if __name__ == "__main__":
    main()


